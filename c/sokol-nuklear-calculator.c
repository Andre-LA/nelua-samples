/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc "c/sokol-nuklear-calculator.c" -o "c/sokol-nuklear-calculator" -I "/home/bart/projects/nelua/nelua-samples/libs" -Wall -fwrapv -O2 -fno-plt -Wextra -Werror -fsanitize=address -fsanitize=undefined -pthread -lX11 -lXi -lXcursor -ldl -lGL -lm */
/* Compile hash: 3at9uSVYVy98vgy67DZvjSjYqgkv */
/* ------------------------------ DIRECTIVES -------------------------------- */
#ifdef __GNUC__
  #ifndef __cplusplus
    #pragma GCC diagnostic error   "-Wimplicit-function-declaration"
    #pragma GCC diagnostic error   "-Wimplicit-int"
    #pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
  #else
    #pragma GCC diagnostic ignored "-Wwrite-strings"
    #pragma GCC diagnostic ignored "-Wnarrowing"
  #endif
  #pragma GCC diagnostic ignored "-Wmissing-braces"
  #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
  #pragma GCC diagnostic ignored "-Wtype-limits"
  #pragma GCC diagnostic ignored "-Wunused-parameter"
  #ifdef __clang__
    #pragma GCC diagnostic ignored "-Wunused"
    #pragma GCC diagnostic ignored "-Wparentheses-equality"
  #else
    #pragma GCC diagnostic ignored "-Wunused-value"
    #pragma GCC diagnostic ignored "-Wunused-variable"
    #pragma GCC diagnostic ignored "-Wunused-function"
    #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
    #ifndef __cplusplus
      #pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
    #endif
  #endif
#endif
#if __STDC_VERSION__ >= 201112L
  #define nelua_static_assert _Static_assert
#elif defined(__cplusplus) && __cplusplus >= 201103L
  #define nelua_static_assert static_assert
#else
  #define nelua_static_assert(x, y)
#endif
nelua_static_assert(sizeof(void*) == 8, "Nelua and C disagree on pointer size");
#define NK_INCLUDE_FIXED_TYPES
#define NK_INCLUDE_STANDARD_IO
#define NK_INCLUDE_DEFAULT_ALLOCATOR
#define NK_INCLUDE_VERTEX_BUFFER_OUTPUT
#define NK_INCLUDE_FONT_BAKING
#define NK_INCLUDE_DEFAULT_FONT
#define NK_INCLUDE_SOFTWARE_FONT
#define NK_INCLUDE_STANDARD_VARARGS
#define NK_IMPLEMENTATION
#include <nuklear.h>
#define SOKOL_APP_API_DECL static
#define SOKOL_APP_IMPL
#define SOKOL_NO_ENTRY
#define SOKOL_GLCORE33
#include <sokol_app.h>
#define SOKOL_GFX_API_DECL static
#define SOKOL_GFX_IMPL
#include <sokol_gfx.h>
#define SOKOL_NUKLEAR_API_DECL static
#define SOKOL_NUKLEAR_IMPL
#include <sokol_nuklear.h>
#include <string.h>
#ifdef __GNUC__
  #define nelua_inline __attribute__((always_inline)) inline
#elif __STDC_VERSION__ >= 199901L
  #define nelua_inline inline
#else
  #define nelua_inline
#endif
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#if __STDC_VERSION__ >= 201112L
  #define nelua_alignof _Alignof
#elif defined(__cplusplus) && __cplusplus >= 201103L
  #define nelua_alignof alignof
#else
  #define nelua_alignof(x)
#endif
#include <stdio.h>
#ifdef __GNUC__
  #define nelua_likely(x) __builtin_expect(x, 1)
  #define nelua_unlikely(x) __builtin_expect(x, 0)
#else
  #define nelua_likely(x) (x)
  #define nelua_unlikely(x) (x)
#endif
#include <stdlib.h>
#if __STDC_VERSION__ >= 201112L
  #define nelua_noreturn _Noreturn
#elif defined(__GNUC__)
  #define nelua_noreturn __attribute__((noreturn))
#else
  #define nelua_noreturn
#endif
#define NLNIL (nlniltype){}
#include <inttypes.h>
#include <errno.h>
/* ------------------------------ DECLARATIONS ------------------------------ */
static sg_context_desc libs_sokol_glue_sapp_sgcontext();
static nelua_inline void nelua_memory_copy(void* dest, void* src, uintptr_t n);
static nelua_inline void nelua_memory_set(void* dest, uint8_t x, uintptr_t n);
static nelua_inline void* nelua_memory_scan(void* src, uint8_t x, uintptr_t size);
typedef struct nelua_span_uint8_ nelua_span_uint8_;
typedef nelua_span_uint8_* nelua_span_uint8__ptr;
typedef uint8_t* nluint8_arr0_ptr;
struct nelua_span_uint8_ {
  nluint8_arr0_ptr data;
  uintptr_t size;
}; nelua_static_assert(sizeof(nelua_span_uint8_) == 16 && nelua_alignof(nelua_span_uint8_) == 8, "Nelua and C disagree on type size or align");
static nelua_inline bool nelua_span_uint8__empty(nelua_span_uint8__ptr self);
typedef uint8_t* nluint8_ptr;
static nelua_inline nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8__ptr self, uintptr_t i);
static nelua_inline bool nelua_isdigit(uint8_t x);
typedef struct {uint8_t v[32];} nluint8_arr32; nelua_static_assert(sizeof(nluint8_arr32) == 32 && nelua_alignof(nluint8_arr32) == 1, "Nelua and C disagree on type size or align");
typedef nluint8_arr32* nluint8_arr32_ptr;
static uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form);
typedef struct nlstring nlstring;
struct nlstring {
  nluint8_arr0_ptr data;
  uintptr_t size;
}; nelua_static_assert(sizeof(nlstring) == 16 && nelua_alignof(nlstring) == 8, "Nelua and C disagree on type size or align");
static nelua_noreturn void nelua_abort();
static void nelua_assert_line_1(bool cond, nlstring msg);
static void nelua_assert_line_2(bool cond, nlstring msg);
static void nelua_addlenmod(nluint8_arr32_ptr form, char* lenmod, size_t lenmodsize);
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
struct nelua_GeneralAllocator {};
static nelua_GeneralAllocator nelua_general_allocator;
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
static nelua_inline void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size);
static nelua_inline void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size);
static nelua_inline void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static nelua_inline void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void* nelua_GeneralAllocator_xalloc(nelua_GeneralAllocator_ptr self, uintptr_t size);
static void nelua_assert_line_3(bool cond, nlstring msg);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
typedef struct nlniltype {} nlniltype;
static nelua_span_uint8_ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s);
static nelua_span_uint8_ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
typedef struct nelua_stringbuilderT nelua_stringbuilderT;
typedef nelua_stringbuilderT* nelua_stringbuilderT_ptr;
struct nelua_stringbuilderT {
  nelua_span_uint8_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
}; nelua_static_assert(sizeof(nelua_stringbuilderT) == 24 && nelua_alignof(nelua_stringbuilderT) == 8, "Nelua and C disagree on type size or align");
static void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self);
static void nelua_stringbuilderT___close(nelua_stringbuilderT_ptr self);
static bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize);
static nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n);
static bool nelua_stringbuilderT_resize(nelua_stringbuilderT_ptr self, uintptr_t n);
static bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n);
typedef struct nlmulret_nlboolean_nlcint {
  bool r1;
  int r2;
} nlmulret_nlboolean_nlcint;
static nlmulret_nlboolean_nlcint nelua_formatarg_1(nelua_stringbuilderT_ptr self, uint8_t c, char* buff, uintptr_t maxitem, nluint8_arr32_ptr form, double arg1);
static void nelua_assert_line_4(bool cond, nlstring msg);
static void nelua_assert_line_5(bool cond, nlstring msg);
typedef struct nlmulret_nlboolean_nlusize {
  bool r1;
  uintptr_t r2;
} nlmulret_nlboolean_nlusize;
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_1(nelua_stringbuilderT_ptr self, nlstring fmt, double __arg1);
static void nelua_assert_line_6(bool cond, nlstring msg);
static nlstring nelua_stringbuilderT_view(nelua_stringbuilderT_ptr self);
static nelua_inline intptr_t nelua_stringbuilderT___len(nelua_stringbuilderT_ptr self);
typedef nlstring* nlstring_ptr;
static void nelua_nlstring_destroy(nlstring_ptr self);
static nlstring nelua_nlstring_copy(nlstring s);
static nelua_inline intptr_t nelua_nlstring___len(nlstring a);
typedef char* nlcchar_arr0_ptr;
static bool nelua_tocstring(nlcchar_arr0_ptr buf, uintptr_t buflen, nlstring s);
static nlstring nelua_tostring_1(double x);
typedef struct {uint8_t v[48];} nluint8_arr48; nelua_static_assert(sizeof(nluint8_arr48) == 48 && nelua_alignof(nluint8_arr48) == 1, "Nelua and C disagree on type size or align");
static void nelua_assert_line_7(bool cond, nlstring msg);
static double nelua_tonumber_1(nlstring x, nlniltype base);
typedef struct {char v[65];} nlcchar_arr65; nelua_static_assert(sizeof(nlcchar_arr65) == 65 && nelua_alignof(nlcchar_arr65) == 1, "Nelua and C disagree on type size or align");
static void nelua_assert_line_8(bool cond);
static void nelua_assert_line_9(bool cond, nlstring msg);
static bool sokol_nuklear_calculator_set = false;
static int64_t sokol_nuklear_calculator_prev = 0;
static int64_t sokol_nuklear_calculator_op = 0;
typedef struct {char v[9];} nlcchar_arr9; nelua_static_assert(sizeof(nlcchar_arr9) == 9 && nelua_alignof(nlcchar_arr9) == 1, "Nelua and C disagree on type size or align");
typedef nlcchar_arr9* nlcchar_arr9_ptr;
static nlcchar_arr9_ptr sokol_nuklear_calculator_numbers = ((nlcchar_arr9_ptr)"789456123");
typedef struct {uint8_t v[4];} nluint8_arr4; nelua_static_assert(sizeof(nluint8_arr4) == 4 && nelua_alignof(nluint8_arr4) == 1, "Nelua and C disagree on type size or align");
static nluint8_arr4 sokol_nuklear_calculator_ops = {{43U, 45U, 42U, 47U}};
static double sokol_nuklear_calculator_a = 0.0;
static double sokol_nuklear_calculator_b = 0.0;
typedef double* nlfloat64_ptr;
static nlfloat64_ptr sokol_nuklear_calculator_current;
typedef struct nk_context NK_context;
typedef NK_context* NK_context_ptr;
static void sokol_nuklear_calculator_calculator(NK_context_ptr ctx);
static nelua_noreturn void nelua_panic_cstring(const char* s);
static nelua_inline int64_t nelua_imod_nlint64(int64_t a, int64_t b);
static nelua_inline int64_t nelua_idiv_nlint64(int64_t a, int64_t b);
static nelua_inline bool nelua_eq_nlint64_nluint8(int64_t a, uint8_t b);
static void sokol_nuklear_calculator_init();
static void sokol_nuklear_calculator_frame();
typedef struct {sg_color_attachment_action v[4];} sg_color_attachment_action_arr4; nelua_static_assert(sizeof(sg_color_attachment_action_arr4) == 80 && nelua_alignof(sg_color_attachment_action_arr4) == 4, "Nelua and C disagree on type size or align");
typedef sapp_event* sapp_event_ptr;
static void sokol_nuklear_calculator_input(sapp_event_ptr event);
static void sokol_nuklear_calculator_cleanup();
static sapp_desc sokol_nuklear_calculator_app_desc = {.init_cb = sokol_nuklear_calculator_init, .frame_cb = sokol_nuklear_calculator_frame, .event_cb = sokol_nuklear_calculator_input, .cleanup_cb = sokol_nuklear_calculator_cleanup, .width = 512, .height = 512, .window_title = "Sokol Nuklear", .enable_clipboard = true, .html5_canvas_resize = true};
static int nelua_main(int nelua_argc, char** nelua_argv);
/* ------------------------------ DEFINITIONS ------------------------------- */
sg_context_desc libs_sokol_glue_sapp_sgcontext() {
  sg_context_desc desc = {0};
  desc.color_format = (sg_pixel_format)sapp_color_format();
  desc.depth_format = (sg_pixel_format)sapp_depth_format();
  desc.sample_count = sapp_sample_count();
  desc.gl.force_gles2 = sapp_gles2();
  desc.metal.device = sapp_metal_get_device();
  desc.metal.renderpass_descriptor_cb = sapp_metal_get_renderpass_descriptor;
  desc.metal.drawable_cb = sapp_metal_get_drawable;
  desc.d3d11.device = sapp_d3d11_get_device();
  desc.d3d11.device_context = sapp_d3d11_get_device_context();
  desc.d3d11.render_target_view_cb = sapp_d3d11_get_render_target_view;
  desc.d3d11.depth_stencil_view_cb = sapp_d3d11_get_depth_stencil_view;
  desc.wgpu.device = sapp_wgpu_get_device();
  desc.wgpu.render_view_cb = sapp_wgpu_get_render_view;
  desc.wgpu.resolve_view_cb = sapp_wgpu_get_resolve_view;
  desc.wgpu.depth_stencil_view_cb = sapp_wgpu_get_depth_stencil_view;
  return desc;
}
void nelua_memory_copy(void* dest, void* src, uintptr_t n) {
  memcpy(dest, src, (size_t)n);
}
void nelua_memory_set(void* dest, uint8_t x, uintptr_t n) {
  memset(dest, (int)x, (size_t)n);
}
void* nelua_memory_scan(void* src, uint8_t x, uintptr_t size) {
  return memchr(src, (int)x, (size_t)size);
}
bool nelua_span_uint8__empty(nelua_span_uint8__ptr self) {
  return (self->size == 0);
}
nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8__ptr self, uintptr_t i) {
  return (&self->data[i]);
}
bool nelua_isdigit(uint8_t x) {
  return ((x >= 48U) && (x <= 57U));
}
void nelua_abort(){
  fflush(stderr);
  abort();
}
void nelua_assert_line_1(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua\033[1m:32:12: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 104, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  assert(p < L_FMTFLAGS.size + 1, \"invalid format (repeated flags)\")\n           \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 129, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_2(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua\033[1m:40:10: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 104, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  assert(not isdigit(strfmt[p]), \"invalid format (width or precision too long)\")\n         \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 140, stderr);
    nelua_abort();
  }
}
uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form) {
  uintptr_t p = (uintptr_t)0U;
  while(((strfmt[p] != 0) && (nelua_memory_scan((void*)((nlstring){(uint8_t*)"-+ #0", 5}).data, strfmt[p], 5U) != (void*)NULL))) {
    p = (p + 1);
  }
  nelua_assert_line_1((p < (((nlstring){(uint8_t*)"-+ #0", 5}).size + 1)), ((nlstring){(uint8_t*)"invalid format (repeated flags)", 31}));
  if(nelua_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if(nelua_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if((strfmt[p] == 46U)) {
    p = (p + 1);
    if(nelua_isdigit(strfmt[p])) {
      p = (p + 1);
    }
    if(nelua_isdigit(strfmt[p])) {
      p = (p + 1);
    }
  }
  nelua_assert_line_2((!nelua_isdigit(strfmt[p])), ((nlstring){(uint8_t*)"invalid format (width or precision too long)", 44}));
  form->v[0] = 37U;
  nelua_memory_copy((void*)(&form->v[1]), (void*)(&strfmt[0]), (p + 1));
  form->v[(p + 2)] = (uint8_t)0U;
  return p;
}
void nelua_addlenmod(nluint8_arr32_ptr form, char* lenmod, size_t lenmodsize) {
  size_t l = (size_t)((intptr_t)strlen((char*)(&form->v[0])));
  uint8_t spec = form->v[(l - 1)];
  nelua_memory_copy((void*)(&form->v[(l - 1)]), (void*)lenmod, (uintptr_t)lenmodsize);
  form->v[((l + lenmodsize) - 1)] = spec;
  form->v[(l + lenmodsize)] = (uint8_t)0U;
}
void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(nelua_unlikely((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(nelua_unlikely((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, (size_t)1U);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(nelua_unlikely((p == (void*)NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(nelua_unlikely((newsize == 0))) {
    if(nelua_likely((p != (void*)NULL))) {
      free(p);
    }
    return (void*)NULL;
  } else if(nelua_unlikely((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void nelua_assert_line_3(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/allocators/allocator.nelua\033[1m:54:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 111, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(p ~= nilptr, 'out of memory')\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 1, 91, stderr);
    nelua_abort();
  }
}
void* nelua_GeneralAllocator_xalloc(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  void* p = nelua_GeneralAllocator_alloc(self, size);
  nelua_assert_line_3((p != (void*)NULL), ((nlstring){(uint8_t*)"out of memory", 13}));
  return p;
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(nelua_likely(((newsize > oldsize) && (p != (void*)NULL)))) {
    memset((void*)(&((nluint8_arr0_ptr)p)[oldsize]), 0, (size_t)(newsize - oldsize));
  }
  return p;
}
nelua_span_uint8_ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(nelua_likely((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GeneralAllocator_alloc0(self, (size * 1)));
    if(nelua_likely((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){data, size};
    }
  }
  return (nelua_span_uint8_){0};
}
void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s) {
  if(nelua_unlikely((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
nelua_span_uint8_ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(nelua_unlikely(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_1(self, NLNIL, size);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(nelua_unlikely(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self) {
  nelua_GeneralAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_uint8_){0};
  self->size = (uintptr_t)0U;
}
void nelua_stringbuilderT___close(nelua_stringbuilderT_ptr self) {
  nelua_stringbuilderT_destroy(self);
}
bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize) {
  uintptr_t needed = (newsize + 1);
  uintptr_t cap = self->data.size;
  if((needed <= cap)) {
    return true;
  }
  if((cap == 0)) {
    cap = 128U;
  }
  while(1) {
    cap = (cap * 2);
    if((cap >= needed)) {
      break;
    }
  }
  self->data = nelua_GeneralAllocator_spanrealloc0_1((&self->allocator), self->data, cap);
  if((self->data.size != cap)) {
    self->data = nelua_GeneralAllocator_spanrealloc0_1((&self->allocator), self->data, needed);
  }
  return (needed <= self->data.size);
}
nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n) {
  if((!nelua_stringbuilderT_grow(self, (self->size + n)))) {
    return (nelua_span_uint8_){0};
  }
  return (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(&(*nelua_span_uint8____atindex((&self->data), self->size)))), .size = ((self->data.size - self->size) - 1)};
}
void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n) {
  uintptr_t newsize = (self->size + n);
  self->size = newsize;
}
bool nelua_stringbuilderT_resize(nelua_stringbuilderT_ptr self, uintptr_t n) {
  if((!nelua_stringbuilderT_grow(self, n))) {
    return false;
  }
  self->size = n;
  return true;
}
bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n) {
  uintptr_t n_1 = (uintptr_t)1U;
  nelua_span_uint8_ p = nelua_stringbuilderT_prepare(self, n_1);
  if(nelua_unlikely(nelua_span_uint8__empty((&p)))) {
    return false;
  }
  nelua_memory_set((void*)p.data, c, n_1);
  self->size = (self->size + n_1);
  return true;
}
void nelua_assert_line_4(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua\033[1m:291:12: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 105, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(false, 'invalid format for argument')\n           \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 1, 93, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_5(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua\033[1m:293:20: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 105, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(nb >= 0 and nb < (@isize)(maxitem), 'unexpected number of bytes written in sprintf')\n                   \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 169, stderr);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlcint nelua_formatarg_1(nelua_stringbuilderT_ptr self, uint8_t c, char* buff, uintptr_t maxitem, nluint8_arr32_ptr form, double arg1) {
  int nb = -1;
  if((c == 99U)) {
    int n = (int)arg1;
    nb = snprintf(buff, (size_t)maxitem, (char*)(&form->v[0]), n);
    goto nelua_next_2;
  }
  if(((((((c == 100U) || (c == 105U)) || (c == 111U)) || (c == 117U)) || (c == 120U)) || (c == 88U))) {
    nelua_addlenmod(form, PRIi64, (size_t)(((intptr_t)strlen(PRIi64)) - 1));
    int64_t n = (int64_t)arg1;
    nb = snprintf(buff, (size_t)maxitem, (char*)(&form->v[0]), n);
    goto nelua_next_2;
  }
  if((((((((c == 97U) || (c == 65U)) || (c == 102U)) || (c == 101U)) || (c == 69U)) || (c == 103U)) || (c == 71U))) {
    double n = arg1;
    nb = snprintf(buff, (size_t)maxitem, (char*)(&form->v[0]), n);
    goto nelua_next_2;
  }
  if((c == 115U)) {
    nlstring s = nelua_tostring_1(arg1);
    maxitem = (s.size + 1);
    buff = (char*)nelua_stringbuilderT_prepare(self, maxitem).data;
    if((buff != NULL)) {
      if(((form->v[1] == c) && (form->v[2] == 0))) {
        nelua_memory_copy((void*)buff, (void*)s.data, s.size);
        nb = (int)s.size;
      } else {
        nb = snprintf(buff, (size_t)maxitem, (char*)(&form->v[0]), s.data);
      }
    }
    nelua_nlstring_destroy((&s));
    if((!(buff != NULL))) {
      return (nlmulret_nlboolean_nlcint){false, 0};
    }
    goto nelua_next_2;
  }
  nelua_assert_line_4(false, ((nlstring){(uint8_t*)"invalid format for argument", 27}));
nelua_next_2:;
  nelua_assert_line_5(((nb >= 0) && (nb < (intptr_t)maxitem)), ((nlstring){(uint8_t*)"unexpected number of bytes written in sprintf", 45}));
  return (nlmulret_nlboolean_nlcint){true, nb};
}
void nelua_assert_line_6(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/stringbuilder.nelua\033[1m:341:21: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 105, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n          assert(nb >= 0, 'missing argument in format')\n                    \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 1, 108, stderr);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_1(nelua_stringbuilderT_ptr self, nlstring fmt, double __arg1) {
  uintptr_t pos = (uintptr_t)0U;
  uintptr_t written = (uintptr_t)0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NLNIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NLNIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = {0};
        uintptr_t maxitem = 120U;
        char* buff = (char*)nelua_stringbuilderT_prepare(self, 120U).data;
        if((!(buff != NULL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        int nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlcint _asgnret_1 = nelua_formatarg_1(self, c, buff, maxitem, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_1;
        }
nelua_next_1:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_assert_line_6((nb >= 0), ((nlstring){(uint8_t*)"missing argument in format", 26}));
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlstring nelua_stringbuilderT_view(nelua_stringbuilderT_ptr self) {
  if(nelua_unlikely((self->size == 0))) {
    return (nlstring){0};
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&(*nelua_span_uint8____atindex((&self->data), 0U)))), .size = self->size};
}
intptr_t nelua_stringbuilderT___len(nelua_stringbuilderT_ptr self) {
  return (intptr_t)self->size;
}
void nelua_nlstring_destroy(nlstring_ptr self) {
  if(nelua_unlikely((self->size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc((&nelua_general_allocator), (void*)self->data);
  self->data = ((nluint8_arr0_ptr)NULL);
  self->size = (uintptr_t)0U;
}
nlstring nelua_nlstring_copy(nlstring s) {
  nlstring clone = {0};
  if(nelua_unlikely((s.size == 0))) {
    return clone;
  }
  clone.data = ((nluint8_arr0_ptr)nelua_GeneralAllocator_xalloc((&nelua_general_allocator), (s.size + 1)));
  nelua_memory_copy((void*)clone.data, (void*)s.data, s.size);
  clone.data[s.size] = (uint8_t)0U;
  clone.size = s.size;
  return clone;
}
intptr_t nelua_nlstring___len(nlstring a) {
  return (intptr_t)a.size;
}
bool nelua_tocstring(nlcchar_arr0_ptr buf, uintptr_t buflen, nlstring s) {
  if(((buf != NULL) && (buflen >= (s.size + 1)))) {
    if((s.size > 0)) {
      nelua_memory_copy((void*)buf, (void*)(&s.data[0]), s.size);
    }
    buf[s.size] = 0;
    return true;
  }
  return false;
}
void nelua_assert_line_7(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/string.nelua\033[1m:735:22: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 98, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(size >= 0 and size < #tmpbuf-1, \"tostring format failed or truncated\")\n                     \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 151, stderr);
    nelua_abort();
  }
}
nlstring nelua_tostring_1(double x) {
  nluint8_arr48 tmpbuf;
  tmpbuf.v[47] = (uint8_t)0U;
  int size = snprintf((char*)(&tmpbuf), 47U, "%.14g", x);
  if((tmpbuf.v[strspn((char*)(&tmpbuf.v[0]), "-0123456789")] == 0)) {
    size = snprintf((char*)(&tmpbuf), 47U, "%.1f", x);
  }
  nelua_assert_line_7(((size >= 0) && (size < 47)), ((nlstring){(uint8_t*)"tostring format failed or truncated", 35}));
  return nelua_nlstring_copy((nlstring){((nluint8_arr0_ptr)(&tmpbuf.v[0])), (uintptr_t)size});
}
void nelua_assert_line_8(bool cond){
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/string.nelua\033[1m:763:21: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n    assert(tocstring(&tmpbuf, #tmpbuf, x)) -- ensure it's zero terminated\n                    \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 258, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_9(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/home/bart/projects/nelua/nelua-lang/lib/string.nelua\033[1m:767:44: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 98, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(len > 0 and len <= (@usize)(#x) and errno == 0, 'failed to convert string to number')\n                                           \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~\033[0m\n", 1, 182, stderr);
    nelua_abort();
  }
}
double nelua_tonumber_1(nlstring x, nlniltype base) {
  char* endptr = NULL;
  nlcchar_arr65 tmpbuf = {0};
  nelua_assert_line_8(nelua_tocstring(((nlcchar_arr0_ptr)(&tmpbuf)), 65U, x));
  errno = 0;
  double n = strtod((char*)(&tmpbuf), (&endptr));
  uintptr_t len = ((uintptr_t)endptr - (uintptr_t)(&tmpbuf));
  nelua_assert_line_9((((len > 0) && (len <= (uintptr_t)nelua_nlstring___len(x))) && (errno == 0)), ((nlstring){(uint8_t*)"failed to convert string to number", 34}));
  return n;
}
void nelua_panic_cstring(const char* s){
  fputs(s, stderr);
  fputc('\n', stderr);
  nelua_abort();
}
int64_t nelua_imod_nlint64(int64_t a, int64_t b){
  if(nelua_unlikely(b == -1)) return 0;
  int64_t r = a % b;
  return (r != 0 && (a ^ b) < 0) ? r + b : r;
}
int64_t nelua_idiv_nlint64(int64_t a, int64_t b){
  if(nelua_unlikely(b == -1)) return 0U - (uint64_t)a;
  if(nelua_unlikely(b == 0)) nelua_panic_cstring("division by zero");
  int64_t q = a / b;
  return q * b == a ? q : q - ((a < 0) ^ (b < 0));
}
bool nelua_eq_nlint64_nluint8(int64_t a, uint8_t b){
  return (uint64_t)a == (uint64_t)b && a >= 0;
}
void sokol_nuklear_calculator_calculator(NK_context_ptr ctx) {
  if((nk_begin(ctx, "Calculator", nk_rect(10.0f, 10.0f, 180.0f, 250.0f), 99U) == 1)) {
    bool solve = false;
    {
      nk_layout_row_dynamic(ctx, 35.0f, 1);
      nelua_stringbuilderT sb = {0};
      nelua_stringbuilderT_prepare((&sb), 256U);
      nlmulret_nlboolean_nlusize _asgnret_1 = nelua_stringbuilderT_writef_1((&sb), ((nlstring){(uint8_t*)"%.2f", 4}), (*sokol_nuklear_calculator_current));
      nelua_stringbuilderT_writef_1((&sb), ((nlstring){(uint8_t*)"%.2f", 4}), (*sokol_nuklear_calculator_current));
      int len = (int)_asgnret_1.r2;
      nk_edit_string(ctx, 512U, (char*)(&(*nelua_span_uint8____atindex((&sb.data), 0U))), (&len), (int)nelua_stringbuilderT___len((&sb)), nk_filter_float);
      nelua_stringbuilderT_resize((&sb), (uintptr_t)len);
      if((len > 0)) {
        (*sokol_nuklear_calculator_current) = nelua_tonumber_1(nelua_stringbuilderT_view((&sb)), NLNIL);
      } else {
        (*sokol_nuklear_calculator_current) = 0.0;
      }
      { /* defer */
        nelua_stringbuilderT___close((&sb));
      }
    }
    nk_layout_row_dynamic(ctx, 35.0f, 4);
    for(int64_t i = 0; i < 16; i = i + 1) {
      if(((i >= 12) && (i < 15))) {
        if((i > 12)) {
          continue;
        }
        if((nk_button_label(ctx, "C") == 1)) {
          double _asgntmp_1 = 0.0;
          double _asgntmp_2 = 0.0;
          int64_t _asgntmp_3 = 0;
          sokol_nuklear_calculator_a = _asgntmp_1;
          sokol_nuklear_calculator_b = _asgntmp_2;
          sokol_nuklear_calculator_op = _asgntmp_3;
          sokol_nuklear_calculator_current = (&sokol_nuklear_calculator_a);
          sokol_nuklear_calculator_set = false;
        }
        if((nk_button_label(ctx, "0") == 1)) {
          (*sokol_nuklear_calculator_current) = ((*sokol_nuklear_calculator_current) * 10.0);
          sokol_nuklear_calculator_set = false;
        }
        if((nk_button_label(ctx, "=") == 1)) {
          solve = true;
          sokol_nuklear_calculator_prev = sokol_nuklear_calculator_op;
          sokol_nuklear_calculator_op = 0;
        }
      } else if((nelua_imod_nlint64((i + 1), 4) != 0)) {
        if((nk_button_text(ctx, (&sokol_nuklear_calculator_numbers->v[((nelua_idiv_nlint64(i, 4) * 3) + nelua_imod_nlint64(i, 4))]), 1) == 1)) {
          (*sokol_nuklear_calculator_current) = ((((*sokol_nuklear_calculator_current) * 10.0) + sokol_nuklear_calculator_numbers->v[((nelua_idiv_nlint64(i, 4) * 3) + nelua_imod_nlint64(i, 4))]) - 48U);
          sokol_nuklear_calculator_set = false;
        }
      } else if((nk_button_text(ctx, (char*)(&sokol_nuklear_calculator_ops.v[nelua_idiv_nlint64(i, 4)]), 1) == 1)) {
        if((!sokol_nuklear_calculator_set)) {
          if((sokol_nuklear_calculator_current != (&sokol_nuklear_calculator_b))) {
            sokol_nuklear_calculator_current = (&sokol_nuklear_calculator_b);
          } else {
            sokol_nuklear_calculator_prev = sokol_nuklear_calculator_op;
            solve = true;
          }
        }
        sokol_nuklear_calculator_op = (int64_t)sokol_nuklear_calculator_ops.v[nelua_idiv_nlint64(i, 4)];
        sokol_nuklear_calculator_set = true;
      }
    }
    if(solve) {
      if(nelua_eq_nlint64_nluint8(sokol_nuklear_calculator_prev, 43U)) {
        sokol_nuklear_calculator_a = (sokol_nuklear_calculator_a + sokol_nuklear_calculator_b);
      } else if(nelua_eq_nlint64_nluint8(sokol_nuklear_calculator_prev, 45U)) {
        sokol_nuklear_calculator_a = (sokol_nuklear_calculator_a - sokol_nuklear_calculator_b);
      } else if(nelua_eq_nlint64_nluint8(sokol_nuklear_calculator_prev, 42U)) {
        sokol_nuklear_calculator_a = (sokol_nuklear_calculator_a * sokol_nuklear_calculator_b);
      } else if(nelua_eq_nlint64_nluint8(sokol_nuklear_calculator_prev, 47U)) {
        sokol_nuklear_calculator_a = (sokol_nuklear_calculator_a / sokol_nuklear_calculator_b);
      }
      sokol_nuklear_calculator_current = (&sokol_nuklear_calculator_a);
      if(sokol_nuklear_calculator_set) {
        sokol_nuklear_calculator_current = (&sokol_nuklear_calculator_b);
      }
      double _asgntmp_4 = 0.0;
      bool _asgntmp_5 = false;
      sokol_nuklear_calculator_b = _asgntmp_4;
      sokol_nuklear_calculator_set = _asgntmp_5;
    }
  }
  nk_end(ctx);
}
void sokol_nuklear_calculator_init() {
  sg_desc sgdesc = (sg_desc){.context = libs_sokol_glue_sapp_sgcontext()};
  sg_setup((&sgdesc));
  snk_desc_t snkdesc = (snk_desc_t){.dpi_scale = sapp_dpi_scale()};
  snk_setup((&snkdesc));
}
void sokol_nuklear_calculator_frame() {
  NK_context_ptr nkctx = snk_new_frame();
  sokol_nuklear_calculator_calculator(nkctx);
  sg_pass_action pass_action = ({
    sg_pass_action _tmp = {0};
    (*(sg_color_attachment_action_arr4*)_tmp.colors) = (sg_color_attachment_action_arr4){{(sg_color_attachment_action){.action = 1, .value = (sg_color){0.0f, 0.0f, 0.0f, 1.0f}}}};
    _tmp;
  });
  {
    int _tmp1 = sapp_width();
    int _tmp2 = sapp_height();
    sg_begin_default_pass((&pass_action), _tmp1, _tmp2);
  }
  {
    int _tmp1 = sapp_width();
    int _tmp2 = sapp_height();
    snk_render(_tmp1, _tmp2);
  }
  sg_end_pass();
  sg_commit();
}
void sokol_nuklear_calculator_input(sapp_event_ptr event) {
  snk_handle_event(event);
}
void sokol_nuklear_calculator_cleanup() {
  snk_shutdown();
  sg_shutdown();
}
int nelua_main(int nelua_argc, char** nelua_argv) {
  sokol_nuklear_calculator_current = (&sokol_nuklear_calculator_a);
  sapp_run((&sokol_nuklear_calculator_app_desc));
  return 0;
}
int main(int argc, char** argv) {
  return nelua_main(argc, argv);
}
